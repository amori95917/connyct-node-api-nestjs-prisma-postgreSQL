# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Branch {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
  type: BranchType!
  contactEmail: String!
  contactNumber: String!
  country: String!
  city: String!
  zipCode: String
  state: String
  street1: String
  street2: String
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

"""The branch type can be CORPORATE and BRANCH_OFFICE"""
enum BranchType {
  CORPORATE
  BRANCH_OFFICE
}

type Company {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
  legalName: String!
  registrationNumber: String
  establishedDate: DateTime
  companyStage: String
  description: String
  ownership: String
  mission: String
  vision: String
  addresses: JSON
  numberOfemployees: Float
  contactEmail: String
  transactions: Float
  isActive: Boolean
  isVerified: Boolean
  ownerId: String
  website: String
  contactNumber: String
  followers: Float
  slogan: String
  branches: [Branch!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type CompanyEdge {
  cursor: String!
  node: Company!
}

type CompanyPaginated {
  edges: [CompanyEdge!]
  nodes: [Company!]
  totalCount: Int!
  hasNextPage: Boolean!
}

type RepliesToReplies {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  text: String
  creatorId: String
  repliedToCommentId: String
  repliedToReplyId: String
  repliedToComment: Comment
  repliedToReplies: Comment
  creator: User
}

type RepliesToRepliesEdge {
  cursor: String!
  node: RepliesToReplies!
}

type RepliesToRepliesPagination {
  edges: [RepliesToRepliesEdge!]
  nodes: [RepliesToReplies!]
  totalCount: Int!
  hasNextPage: Boolean!
}

type Replies {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  text: String
  postId: String
  creatorId: String
  repliedToCommentId: String
  repliedTo: Comment
  replies(paginate: PaginationArgs = {skip: 0, take: 50}, order: OrderCommentsList = {direction: asc}): RepliesToRepliesPagination!
  creator: User!
  mentions: [User!]!
}

input PaginationArgs {
  skip: Float!
  take: Float!
}

input OrderCommentsList {
  direction: OrderDirection!
  orderBy: CommentOrderBy!
}

"""
Likely likely to sort a list of items when presented with an argument `orderBy`.
"""
enum OrderDirection {
  asc
  desc
}

"""Order by:createdAt"""
enum CommentOrderBy {
  createdAt
}

type RepliesEdge {
  cursor: String!
  node: Replies!
}

type RepliesPagination {
  edges: [RepliesEdge!]
  nodes: [Replies!]
  totalCount: Int!
  hasNextPage: Boolean!
}

type Comment {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  text: String!
  creatorId: String!
  postId: String
  repliedToCommentId: String
  repliedToReplyId: String
  rating: Int
  myRatingStatus: RatingStatus!
  creator: User!
  mentions: [User!]!
  post: Post
  replies(paginate: PaginationArgs = {skip: 0, take: 50}, order: OrderCommentsList = {direction: asc}): RepliesPagination
}

enum RatingStatus {
  NEUTRAL
  UPVOTED
  DOWNVOTED
}

type CommentEdge {
  cursor: String!
  node: Comment!
}

type CommentPagination {
  edges: [CommentEdge!]
  nodes: [Comment!]
  totalCount: Int!
  hasNextPage: Boolean!
}

type Product {
  id: ID!
  name: String
  description: String
  image: String!
}

type Tag {
  id: ID!
  name: String!
}

type Post {
  id: ID!
  text: String!
  creator: User!
  rating: Int!
  createdAt: DateTime!
  myRatingStatus: RatingStatus!
  creatorId: String!
  comments: [Comment!]!
  isSaleAble: Boolean!
  companyId: String!
  product: [Product!]!
  tags: [Tag!]!
}

type User {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  fullName: String
  email: String!
  isValid: Boolean
  isSuperuser: Boolean
  confirm: Boolean
  emailToken: String
  posts: [Post!]
  company: [Company!]
  isAdmin: Boolean!
}

type UserEdge {
  cursor: String!
  node: User!
}

type UserPaginated {
  edges: [UserEdge!]
  nodes: [User!]
  totalCount: Int!
  hasNextPage: Boolean!
}

type Token {
  """JWT access token"""
  accessToken: String!

  """JWT refresh token"""
  refreshToken: String!
}

type Auth {
  """JWT access token"""
  accessToken: String!

  """JWT refresh token"""
  refreshToken: String!
  user: User!
  role: String!
  company: [Company!]
}

type UserError {
  message: String!
  field: String
  code: String
  status: Float
}

type RatePayload implements MutationPayload {
  errors: [UserError!]
  isRateSuccessful: Boolean!
}

interface MutationPayload {
  errors: [UserError!]
}

type NewReplyPayload implements MutationPayload {
  errors: [UserError!]
  comment: Comment
}

type CommentPaginationPayload {
  errors: [UserError!]
  comments: CommentPagination
}

type CreatePostPayload implements MutationPayload {
  errors: [UserError!]
  post: Post
  product: [Product!]
  tags: [Tag!]
}

type DeletePostPayload implements MutationPayload {
  errors: [UserError!]
  isDeleteSuccessful: Boolean!
}

type UpdatePostPayload implements MutationPayload {
  errors: [UserError!]
  post: Post
  product: Product
  tags: [Tag!]
}

type TagEdge {
  cursor: String!
  node: Tag!
}

type TagPagination {
  edges: [TagEdge!]
  nodes: [Tag!]
  totalCount: Int!
  hasNextPage: Boolean!
}

type InvitedEmployee {
  id: ID!
  invitedId: String!
  invitedEmail: String!
  invitedRoleId: String!
  isInviteAccepted: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FollowUserToUser {
  id: ID!
  followedToId: String!
  followedById: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FollowCompany {
  id: ID!
  followedById: String!
  followedToId: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Industry {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  type: String!
  description: String
  isActive: Boolean
}

type IndustryPayload {
  error: String
  industries: [Industry!]
  industry: Industry
  isDeletedSuccessful: Boolean
}

type Reactions {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  reactionType: String!
}

type Likes {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  postId: String!
  reactionId: String!
  userId: String!
  reactions: Reactions
  user: User
}

type LikesEdge {
  cursor: String!
  node: Likes!
}

type ReactionsPagination {
  edges: [LikesEdge!]
  nodes: [Likes!]
  totalCount: Int!
  hasNextPage: Boolean!
}

type LikesPayload {
  likes: Likes
  isDisliked: Boolean
}

type CustomError {
  message: String!
  code: String
  statusCode: Float
}

type CommentReactions {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  reactionId: String
  commentId: String
  creatorId: String
  comment: Comment
  reactors: [User!]
}

type CommentReactionsEdge {
  cursor: String!
  node: CommentReactions!
}

type CommentReactionsPagination {
  edges: [CommentReactionsEdge!]
  nodes: [CommentReactions!]
  totalCount: Int!
  hasNextPage: Boolean!
}

type CommentReactionsPayload {
  errors: [CustomError!]
  commentReactions: CommentReactions
  isDisliked: Boolean
}

type CommentReactionPaginationPayload {
  errors: [CustomError!]
  reactions: CommentReactionsPagination
}

type Query {
  listUsers(paginate: PaginationArgs = {skip: 0, take: 50}, order: OrderListUsers = {direction: desc, orderBy: username}, filter: FilterListUsers): UserPaginated!
  me: User!
  getUser(userId: String!): User!
  getCompanysFollowedByUser(paginate: PaginationArgs, order: OrderFollowedCompanyList): CompanyPaginated
  companiesSuggestions(paginate: PaginationArgs = {skip: 0, take: 50}, order: OrderListCompanies = {direction: desc, orderBy: name}, filter: FilterListCompanies): CompanyPaginated!
  companies(paginate: PaginationArgs = {skip: 0, take: 50}, order: OrderListCompanies = {direction: desc, orderBy: name}, filter: FilterListCompanies): CompanyPaginated!
  getCompanyById(id: String!): Company!
  getBranchesByCompanyId(id: String!): [Branch!]!
  getTags(paginate: PaginationArgs = {skip: 0, take: 50}, order: OrderTagList = {direction: asc, orderBy: createdAt}, query: TagQuery = {name: ""}): TagPagination!
  getPostsByCompanyId(id: String!): [Post!]!
  getCompanyPostsFollowedByUser: [Post!]
  comments(postId: String!, paginate: PaginationArgs = {skip: 0, take: 50}, order: OrderCommentsList = {direction: asc}): CommentPaginationPayload!
  getIndustry: IndustryPayload!
  getReactions: [Reactions!]!
  getLikesByPost(postId: String!, paginate: PaginationArgs = {skip: 0, take: 50}, order: ReactionsOrderList = {direction: desc}): ReactionsPagination!
  getUsersByPostReaction(reactionType: String!, paginate: PaginationArgs = {skip: 0, take: 50}, order: ReactionsOrderList = {direction: desc}): ReactionsPagination!
  commentReactions(commentId: String!, paginate: PaginationArgs = {skip: 0, take: 50}, order: CommentReactionsOrderList = {direction: asc, orderBy: createdAt}): CommentReactionPaginationPayload!
}

input OrderListUsers {
  direction: OrderDirection!
  orderBy: UsersOrderBy!
}

"""Order by: username, createdAt, email"""
enum UsersOrderBy {
  username
  createdAt
  email
}

input FilterListUsers {
  omni: String = null
  isValid: Boolean = null
}

input OrderFollowedCompanyList {
  direction: OrderDirection!
  orderBy: FollowedCompanyOrderBy!
}

"""Order by: createdAt"""
enum FollowedCompanyOrderBy {
  createdAt
}

input OrderListCompanies {
  direction: OrderDirection!
  orderBy: CompaniesOrderBy!
}

"""Order by: name, legalName, createdAt"""
enum CompaniesOrderBy {
  name
  legalName
  createdAt
}

input FilterListCompanies {
  omni: String = null
}

input OrderTagList {
  direction: OrderDirection!
  orderBy: TagOrderBy!
}

"""Order by:createdAt"""
enum TagOrderBy {
  createdAt
}

input TagQuery {
  name: String = null
}

input ReactionsOrderList {
  direction: OrderDirection!
  orderBy: ReactionsOrderBy!
}

"""Order By:createdAt"""
enum ReactionsOrderBy {
  createdAt
}

input CommentReactionsOrderList {
  direction: OrderDirection!
  orderBy: CommentReactionsOrderBy
}

"""Order by:createdAt"""
enum CommentReactionsOrderBy {
  createdAt
}

type Mutation {
  updateStatusUser(data: UpdateStatusUserInput!): User!
  updateUser(data: UpdateUserInput!): User!
  changePassword(data: ChangePasswordInput!): User!
  signup(data: SignupInput!): Auth!
  login(data: LoginInput!): Auth!
  loginLinkAccess(data: LoginLinkAccessInput!): Boolean!
  refreshToken(token: String!): Token!
  confirmEmail(token: String!): Token!
  requestConfirmEmail(data: RequestConfirmEmailInput!): Boolean!
  resetPassword(data: ResetPasswordInput!): Token!
  requestResetPassword(data: RequestResetPasswordInput!): Boolean!
  logout: Boolean!
  createCompany(data: CreateCompanyInput!): Company!
  createCompanyGeneralInfo(data: CreateCompanyGeneralInput!): Company!
  editCompany(id: String!, data: CompanyEditInput!): Company!
  createCompanyBranch(id: String!, data: CompanyBranchInput!): Branch!
  editCompanyBranch(id: String!, data: CompanyBranchEditInput!): Branch!
  deleteCompanyBranch(id: String!, companyId: String!): Branch!
  createPost(data: CreatePostInput!, file: [Upload!]): CreatePostPayload!
  updatePost(id: String!, productId: String, input: CreatePostInput, file: Upload): UpdatePostPayload!
  deletePost(postId: String!): DeletePostPayload!
  upvotePost(postId: Int!): RatePayload!
  downvotePost(postId: Int!): RatePayload!
  removeRatingFromPost(postId: Int!): RatePayload!
  commentToPost(postId: String!, input: CreateCommentInput!, mention: CreateMentionsInput): NewReplyPayload!
  commentReply(commentId: String!, input: CreateCommentInput!, mention: CreateMentionsInput): NewReplyPayload!
  replyToReply(commentId: String!, input: CreateCommentInput!, mention: CreateMentionsInput): NewReplyPayload!
  upvoteComment(commentId: String!): RatePayload!
  downvoteComment(commentId: String!): RatePayload!
  removeRatingFromComment(commentId: String!): RatePayload!
  inviteEmployee(data: InvitedEmployeeInput!): InvitedEmployee!
  createEmployee(data: UserEmployeeInput!): User!
  followCompany(data: FollowCompanyInput!): FollowCompany!
  unfollowCompany(data: UnfollowCompanyInput!): String!
  followUserToUser(data: FollowUserToUserInput!): FollowUserToUser!
  unfollowUser(data: UnfollowUserInput!): String!
  createIndustry(data: IndustryInput!): IndustryPayload!
  updateIndustry(id: String!, data: IndustryInput!): IndustryPayload!
  deleteIndustry(id: String!): IndustryPayload!
  activeOrDeactiveIndustry(id: String!): IndustryPayload!
  createLikes(data: LikesInput!): LikesPayload!
  removeLike(postId: String!): Likes!
  commentReaction(input: CommentReactionsInput!): CommentReactionsPayload!
}

input UpdateStatusUserInput {
  userId: String!
  status: Boolean!
}

input UpdateUserInput {
  userId: String
  fullName: String
}

input ChangePasswordInput {
  oldPassword: String!
  newPassword: String!
}

input SignupInput {
  fullName: String
  email: String!
  password: String!
  isCompanyAccount: Boolean
  legalName: String
}

input LoginInput {
  emailOrUsername: String!
  password: String!
}

input LoginLinkAccessInput {
  email: String!
}

input RequestConfirmEmailInput {
  email: String!
}

input ResetPasswordInput {
  newPassword: String!
  token: String!
}

input RequestResetPasswordInput {
  email: String!
}

input CreateCompanyInput {
  name: String!
  legalName: String!
  registrationNumber: String!
  establishedDate: DateTime!
  businessType: String!
  ownership: String!
  companyStage: String!
  branches: Float!
  numberOfemployees: Float!
  transactions: Float!
}

input CreateCompanyGeneralInput {
  name: String!
  legalName: String!
  registrationNumber: String!
  establishedDate: DateTime!
  businessType: String!
  ownership: String!
  companyStage: String!
}

input CompanyEditInput {
  legalName: String
  name: String
  registrationNumber: String!
  establishedDate: DateTime!
  companyStage: String
  description: String
  mission: String
  vision: String
  ownership: String
  contactEmail: String!
  numberOfemployees: Float
  transactions: Float
  website: String
  contactNumber: String
  slogan: String
}

input CompanyBranchInput {
  type: BranchType!
  name: String
  contactEmail: String!
  contactNumber: String!
  country: String
  city: String
  zipCode: String
  state: String
  street1: String
  street2: String
}

input CompanyBranchEditInput {
  type: BranchType
  name: String
  contactEmail: String
  contactNumber: String
  country: String
  city: String
  zipCode: String
  state: String
  street1: String
  street2: String
}

input CreatePostInput {
  text: String!
  tags: [String!]
  name: String
  description: String
  companyId: String!
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

input CreateCommentInput {
  text: String!
}

input CreateMentionsInput {
  mentionIds: [String!]
}

input InvitedEmployeeInput {
  invitedEmail: String!
  role: String!
}

input UserEmployeeInput {
  isInviteAccepted: Boolean!
  firstName: String!
  lastName: String!
  email: String!
  password: String!
  role: String!
}

input FollowCompanyInput {
  followedToId: String!
}

input UnfollowCompanyInput {
  companyId: String!
}

input FollowUserToUserInput {
  followedToID: String!
}

input UnfollowUserInput {
  userId: String!
}

input IndustryInput {
  type: String!
  description: String
}

input LikesInput {
  postId: String!
  reactionType: String!
}

input CommentReactionsInput {
  reactionType: String!
  commentId: String!
}