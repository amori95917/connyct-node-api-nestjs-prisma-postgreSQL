# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Branch {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
  type: BranchType!
  contactEmail: String!
  contactNumber: String!
  country: String!
  city: String!
  zipCode: String
  state: String
  street1: String
  street2: String
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

"""The branch type can be CORPORATE and BRANCH_OFFICE"""
enum BranchType {
  CORPORATE
  BRANCH_OFFICE
}

type Company {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
  legalName: String!
  registrationNumber: String
  establishedDate: DateTime
  companyStage: String
  description: String
  ownership: String
  mission: String
  vision: String
  addresses: JSON
  numberOfemployees: Float
  contactEmail: String
  transactions: Float
  isActive: Boolean
  isVerified: Boolean
  ownerId: String
  website: String
  contactNumber: String
  followers: Float
  slogan: String
  branches: [Branch!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type CompanyEdge {
  cursor: String!
  node: Company!
}

type CompanyPaginated {
  edges: [CompanyEdge!]
  nodes: [Company!]
  totalCount: Int!
  hasNextPage: Boolean!
}

type Comment {
  id: ID!
  text: String!
  creator: User!
  rating: Int!
  myRatingStatus: RatingStatus!
  createdAt: DateTime!
  post: Post
  postId: String
  repliedTo: Comment
  repliedToId: String
  replies: [Comment!]!
  creatorId: String!
}

enum RatingStatus {
  NEUTRAL
  UPVOTED
  DOWNVOTED
}

type CommentEdge {
  cursor: String!
  node: Comment!
}

type CommentPagination {
  edges: [CommentEdge!]
  nodes: [Comment!]
  totalCount: Int!
  hasNextPage: Boolean!
}

type Product {
  id: ID!
  name: String
  description: String
  image: String!
}

type Tag {
  id: ID!
  name: String!
}

type Post {
  id: ID!
  text: String!
  creator: User!
  rating: Int!
  createdAt: DateTime!
  myRatingStatus: RatingStatus!
  creatorId: String!
  comments: [Comment!]!
  isSaleAble: Boolean!
  companyId: String!
  product: [Product!]!
  tags: [Tag!]!
}

type User {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  fullName: String
  email: String!
  isValid: Boolean
  isSuperuser: Boolean
  confirm: Boolean
  emailToken: String
  posts: [Post!]
  company: [Company!]
  isAdmin: Boolean!
}

type UserEdge {
  cursor: String!
  node: User!
}

type UserPaginated {
  edges: [UserEdge!]
  nodes: [User!]
  totalCount: Int!
  hasNextPage: Boolean!
}

type Token {
  """JWT access token"""
  accessToken: String!

  """JWT refresh token"""
  refreshToken: String!
}

type Auth {
  """JWT access token"""
  accessToken: String!

  """JWT refresh token"""
  refreshToken: String!
  user: User!
  role: String!
  company: [Company!]
}

type UserError {
  message: String!
  field: String
}

type RatePayload implements MutationPayload {
  errors: [UserError!]
  isRateSuccessful: Boolean!
}

interface MutationPayload {
  errors: [UserError!]
}

type NewReplyPayload implements MutationPayload {
  errors: [UserError!]
  comment: Comment
}

type CreatePostPayload implements MutationPayload {
  errors: [UserError!]
  post: Post
  product: [Product!]
  tags: [Tag!]
}

type DeletePostPayload implements MutationPayload {
  errors: [UserError!]
  isDeleteSuccessful: Boolean!
}

type UpdatePostPayload implements MutationPayload {
  errors: [UserError!]
  post: Post
  product: Product
  tags: [Tag!]
}

type TagEdge {
  cursor: String!
  node: Tag!
}

type TagPagination {
  edges: [TagEdge!]
  nodes: [Tag!]
  totalCount: Int!
  hasNextPage: Boolean!
}

type InvitedEmployee {
  id: ID!
  invitedId: String!
  invitedEmail: String!
  invitedRoleId: String!
  isInviteAccepted: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FollowUserToUser {
  id: ID!
  followedToId: String!
  followedById: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FollowCompany {
  id: ID!
  followedById: String!
  followedToId: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Industry {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  type: String!
  description: String
  isActive: Boolean
}

type IndustryPayload {
  error: String
  industries: [Industry!]
  industry: Industry
  isDeletedSuccessful: Boolean
}

type Reactions {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  reactionType: String!
}

type Likes {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  postId: String!
  reactionId: String!
  userId: String!
  reactions: Reactions
  user: User
}

type LikesEdge {
  cursor: String!
  node: Likes!
}

type ReactionsPagination {
  edges: [LikesEdge!]
  nodes: [Likes!]
  totalCount: Int!
  hasNextPage: Boolean!
}

type LikesPayload {
  likes: Likes
  isDisliked: Boolean
}

type Query {
  listUsers(paginate: PaginationArgs = {skip: 0, take: 50}, order: OrderListUsers = {direction: desc, orderBy: username}, filter: FilterListUsers): UserPaginated!
  me: User!
  getUser(userId: String!): User!
  getCompanysFollowedByUser(paginate: PaginationArgs, order: OrderFollowedCompanyList): CompanyPaginated
  companiesSuggestions(paginate: PaginationArgs = {skip: 0, take: 50}, order: OrderListCompanies = {direction: desc, orderBy: name}, filter: FilterListCompanies): CompanyPaginated!
  companies(paginate: PaginationArgs = {skip: 0, take: 50}, order: OrderListCompanies = {direction: desc, orderBy: name}, filter: FilterListCompanies): CompanyPaginated!
  getCompanyById(id: String!): Company!
  getBranchesByCompanyId(id: String!): [Branch!]!
  getTags(paginate: PaginationArgs = {skip: 0, take: 50}, order: OrderTagList = {direction: asc}, query: TagQuery = {name: ""}): TagPagination!
  getPostsByCompanyId(id: String!): [Post!]!
  getCompanyPostsFollowedByUser: [Post!]
  getComments(postId: String!, paginate: PaginationArgs = {skip: 0, take: 50}, order: OrderCommentsList = {direction: asc}): CommentPagination!
  getIndustry: IndustryPayload!
  getReactions: [Reactions!]!
  getLikesByPost(postId: String!, paginate: PaginationArgs = {skip: 0, take: 50}, order: ReactionsOrderList = {direction: desc}): ReactionsPagination!
  getUsersByPostReaction(reactionType: String!, paginate: PaginationArgs = {skip: 0, take: 50}, order: ReactionsOrderList = {direction: desc}): ReactionsPagination!
}

input PaginationArgs {
  skip: Float!
  take: Float!
}

input OrderListUsers {
  direction: OrderDirection!
  orderBy: UsersOrderBy!
}

"""
Likely likely to sort a list of items when presented with an argument `orderBy`.
"""
enum OrderDirection {
  asc
  desc
}

"""Order by: username, createdAt, email"""
enum UsersOrderBy {
  username
  createdAt
  email
}

input FilterListUsers {
  omni: String = null
  isValid: Boolean = null
}

input OrderFollowedCompanyList {
  direction: OrderDirection!
  orderBy: FollowedCompanyOrderBy!
}

"""Order by: createdAt"""
enum FollowedCompanyOrderBy {
  createdAt
}

input OrderListCompanies {
  direction: OrderDirection!
  orderBy: CompaniesOrderBy!
}

"""Order by: name, legalName, createdAt"""
enum CompaniesOrderBy {
  name
  legalName
  createdAt
}

input FilterListCompanies {
  omni: String = null
}

input OrderTagList {
  direction: OrderDirection!
  orderBy: TagOrderBy!
}

enum TagOrderBy {
  name
}

input TagQuery {
  name: String = null
}

input OrderCommentsList {
  direction: OrderDirection!
  orderBy: CommentOrderBy!
}

"""Order by:createdAt"""
enum CommentOrderBy {
  createdAt
}

input ReactionsOrderList {
  direction: OrderDirection!
  orderBy: ReactionsOrderBy!
}

"""Order By:createdAt"""
enum ReactionsOrderBy {
  createdAt
}

type Mutation {
  updateStatusUser(data: UpdateStatusUserInput!): User!
  updateUser(data: UpdateUserInput!): User!
  changePassword(data: ChangePasswordInput!): User!
  signup(data: SignupInput!): Auth!
  login(data: LoginInput!): Auth!
  loginLinkAccess(data: LoginLinkAccessInput!): Boolean!
  refreshToken(token: String!): Token!
  confirmEmail(token: String!): Token!
  requestConfirmEmail(data: RequestConfirmEmailInput!): Boolean!
  resetPassword(data: ResetPasswordInput!): Token!
  requestResetPassword(data: RequestResetPasswordInput!): Boolean!
  logout: Boolean!
  createCompany(data: CreateCompanyInput!): Company!
  createCompanyGeneralInfo(data: CreateCompanyGeneralInput!): Company!
  editCompany(id: String!, data: CompanyEditInput!): Company!
  createCompanyBranch(id: String!, data: CompanyBranchInput!): Branch!
  editCompanyBranch(id: String!, data: CompanyBranchEditInput!): Branch!
  deleteCompanyBranch(id: String!, companyId: String!): Branch!
  createPost(data: CreatePostInput!, file: [Upload!]): CreatePostPayload!
  updatePost(id: String!, productId: String, input: CreatePostInput, file: Upload): UpdatePostPayload!
  deletePost(postId: String!): DeletePostPayload!
  upvotePost(postId: Int!): RatePayload!
  downvotePost(postId: Int!): RatePayload!
  removeRatingFromPost(postId: Int!): RatePayload!
  replyToPost(postId: String!, input: CreateCommentInput!): NewReplyPayload!
  replyToComment(commentId: String!, postId: String!, input: CreateCommentInput!): NewReplyPayload!
  upvoteComment(commentId: String!): RatePayload!
  downvoteComment(commentId: String!): RatePayload!
  removeRatingFromComment(commentId: String!): RatePayload!
  inviteEmployee(data: InvitedEmployeeInput!): InvitedEmployee!
  createEmployee(data: UserEmployeeInput!): User!
  followCompany(data: FollowCompanyInput!): FollowCompany!
  unfollowCompany(data: UnfollowCompanyInput!): String!
  followUserToUser(data: FollowUserToUserInput!): FollowUserToUser!
  unfollowUser(data: UnfollowUserInput!): String!
  createIndustry(data: IndustryInput!): IndustryPayload!
  updateIndustry(id: String!, data: IndustryInput!): IndustryPayload!
  deleteIndustry(id: String!): IndustryPayload!
  activeOrDeactiveIndustry(id: String!): IndustryPayload!
  createLikes(data: LikesInput!): LikesPayload!
  removeLike(postId: String!): Likes!
}

input UpdateStatusUserInput {
  userId: String!
  status: Boolean!
}

input UpdateUserInput {
  userId: String
  fullName: String
}

input ChangePasswordInput {
  oldPassword: String!
  newPassword: String!
}

input SignupInput {
  fullName: String
  email: String!
  password: String!
  isCompanyAccount: Boolean
  legalName: String
}

input LoginInput {
  emailOrUsername: String!
  password: String!
}

input LoginLinkAccessInput {
  email: String!
}

input RequestConfirmEmailInput {
  email: String!
}

input ResetPasswordInput {
  newPassword: String!
  token: String!
}

input RequestResetPasswordInput {
  email: String!
}

input CreateCompanyInput {
  name: String!
  legalName: String!
  registrationNumber: String!
  establishedDate: DateTime!
  businessType: String!
  ownership: String!
  companyStage: String!
  branches: Float!
  numberOfemployees: Float!
  transactions: Float!
}

input CreateCompanyGeneralInput {
  name: String!
  legalName: String!
  registrationNumber: String!
  establishedDate: DateTime!
  businessType: String!
  ownership: String!
  companyStage: String!
}

input CompanyEditInput {
  legalName: String
  name: String
  registrationNumber: String!
  establishedDate: DateTime!
  companyStage: String
  description: String
  mission: String
  vision: String
  ownership: String
  contactEmail: String!
  numberOfemployees: Float
  transactions: Float
  website: String
  contactNumber: String
  slogan: String
}

input CompanyBranchInput {
  type: BranchType!
  name: String
  contactEmail: String!
  contactNumber: String!
  country: String
  city: String
  zipCode: String
  state: String
  street1: String
  street2: String
}

input CompanyBranchEditInput {
  type: BranchType
  name: String
  contactEmail: String
  contactNumber: String
  country: String
  city: String
  zipCode: String
  state: String
  street1: String
  street2: String
}

input CreatePostInput {
  text: String!
  tags: [String!]
  name: String
  description: String
  companyId: String!
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

input CreateCommentInput {
  text: String!
}

input InvitedEmployeeInput {
  invitedEmail: String!
  role: String!
}

input UserEmployeeInput {
  isInviteAccepted: Boolean!
  firstName: String!
  lastName: String!
  email: String!
  password: String!
  role: String!
}

input FollowCompanyInput {
  followedToId: String!
}

input UnfollowCompanyInput {
  companyId: String!
}

input FollowUserToUserInput {
  followedToID: String!
}

input UnfollowUserInput {
  userId: String!
}

input IndustryInput {
  type: String!
  description: String
}

input LikesInput {
  postId: String!
  reactionType: String!
}