# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type CustomError {
  message: String!
  code: String
  statusCode: Float
}

type Branch {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
  type: BranchType!
  contactEmail: String!
  contactNumber: String!
  country: String!
  city: String!
  zipCode: String
  state: String
  street1: String
  street2: String
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

"""The branch type can be CORPORATE and BRANCH_OFFICE"""
enum BranchType {
  CORPORATE
  BRANCH_OFFICE
}

type Company {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
  legalName: String!
  registrationNumber: String
  establishedDate: DateTime
  companyStage: String
  description: String
  ownership: String
  mission: String
  vision: String
  addresses: JSON
  numberOfemployees: Float
  contactEmail: String
  transactions: Float
  isActive: Boolean
  isVerified: Boolean
  ownerId: String
  website: String
  contactNumber: String
  followers: Float
  slogan: String
  branches: [Branch!]
  avatar: String
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type CompanyPaginated {
  edges: [CompanyEdge!]
  pageInfo: CompanyPageInfo
  totalCount: Float!
}

type CompanyEdge {
  cursor: String
  node: Company
}

type CompanyPageInfo {
  startCursor: String
  endCursor: String
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
}

type RepliesToReplies {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  text: String
  creatorId: String
  repliedToCommentId: String
  repliedToReplyId: String
  repliedToParentComment: Comment
  creator: User
}

type RepliesToRepliesPagination {
  edges: [RepliesToRepliesEdge!]
  pageInfo: RepliesToRepliesPageInfo
  totalCount: Float!
}

type RepliesToRepliesEdge {
  cursor: String
  node: RepliesToReplies
}

type RepliesToRepliesPageInfo {
  startCursor: String
  endCursor: String
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
}

type Replies {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  text: String
  postId: String
  creatorId: String
  repliedToCommentId: String
  repliedTo: Comment!
  replies(
    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
    order: OrderCommentsList = {direction: asc, orderBy: createdAt}
  ): RepliesToRepliesPagination!
  creator: User!
  mentions: [User!]!
  post: Post
}

input OrderCommentsList {
  direction: OrderDirection!
  orderBy: CommentOrderBy!
}

"""
Likely likely to sort a list of items when presented with an argument `orderBy`.
"""
enum OrderDirection {
  asc
  desc
}

"""Order by:createdAt"""
enum CommentOrderBy {
  createdAt
}

type RepliesPagination {
  edges: [RepliesEdge!]
  pageInfo: RepliesPageInfo
  totalCount: Float!
}

type RepliesEdge {
  cursor: String
  node: Replies
}

type RepliesPageInfo {
  startCursor: String
  endCursor: String
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
}

type Comment {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  text: String!
  creatorId: String!
  postId: String
  repliedToCommentId: String
  repliedToReplyId: String
  rating: Int
  replies(
    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
    order: OrderCommentsList = {direction: asc, orderBy: createdAt}
  ): RepliesPagination
  myRatingStatus: RatingStatus!
  creator: User!
  mentions: [User!]!
  post: Post
}

enum RatingStatus {
  NEUTRAL
  UPVOTED
  DOWNVOTED
}

type CommentPagination {
  edges: [CommentEdge!]
  pageInfo: CommentPageInfo
  totalCount: Float!
}

type CommentEdge {
  cursor: String
  node: Comment
}

type CommentPageInfo {
  startCursor: String
  endCursor: String
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
}

type PostImage {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  metaTitle: String
  imageURL: String
  description: String
  postId: String
}

type Tag {
  id: ID!
  name: String!
}

type Post {
  id: ID!
  text: String!
  creator: User!
  rating: Int!
  createdAt: DateTime!
  myRatingStatus: RatingStatus!
  creatorId: String!
  comments: [Comment!]!
  isSaleAble: Boolean
  companyId: String
  postImage: [PostImage!]!
  tags: [Tag!]!
  company: Company
}

type PostPagination {
  edges: [PostEdge!]
  pageInfo: PostPageInfo
  totalCount: Float!
}

type PostEdge {
  cursor: String
  node: Post
}

type PostPageInfo {
  startCursor: String
  endCursor: String
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
}

type User {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  fullName: String
  username: String
  email: String!
  isValid: Boolean
  isSuperuser: Boolean
  confirm: Boolean
  emailToken: String
  posts: [Post!]
  company: [Company!]
  isAdmin: Boolean!
}

type UserPaginated {
  edges: [UserEdge!]
  pageInfo: UserPageInfo
  totalCount: Float!
}

type UserEdge {
  cursor: String
  node: User
}

type UserPageInfo {
  startCursor: String
  endCursor: String
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
}

type Token {
  """JWT access token"""
  accessToken: String

  """JWT refresh token"""
  refreshToken: String
}

type Auth {
  """JWT access token"""
  accessToken: String

  """JWT refresh token"""
  refreshToken: String
  errors: [CustomError!]
  user: User
  role: String
  company: [Company!]
}

type UserProfile {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  address: String
  phoneNo: String
  profileImage: String
  user: User
}

type UserProfilePayload {
  errors: CustomError
  userProfile: UserProfile
}

type CompanyPayload {
  errors: [CustomError!]
  company: Company
}

type UserError {
  message: String!
  field: String
  code: String
  status: Float
}

type RatePayload implements MutationPayload {
  errors: [UserError!]
  isRateSuccessful: Boolean!
}

interface MutationPayload {
  errors: [UserError!]
}

type NewReplyPayload implements MutationPayload {
  errors: [UserError!]
  comment: Comment
}

type CommentPaginationPayload {
  errors: [UserError!]
  comments: CommentPagination
}

type CreatePostPayload {
  errors: [CustomError!]
  post: Post
  postImage: [PostImage!]
  tags: [Tag!]
}

type DeletePostPayload {
  errors: [CustomError!]
  isDeleteSuccessful: Boolean
}

type UpdatePostPayload {
  errors: [CustomError!]
  post: Post
  postImage: PostImage
  tags: [Tag!]
}

type TagEdge {
  cursor: String!
  node: Tag!
}

type TagPagination {
  edges: [TagEdge!]
  nodes: [Tag!]
  totalCount: Int!
  hasNextPage: Boolean!
}

type InvitedEmployee {
  id: ID!
  invitedId: String!
  invitedEmail: String!
  invitedRoleId: String!
  isInviteAccepted: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FollowUserToUser {
  id: ID!
  followedToId: String!
  followedById: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FollowCompany {
  id: ID!
  followedById: String!
  followedToId: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Industry {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  type: String!
  description: String
  isActive: Boolean
}

type IndustryPayload {
  error: String
  industries: [Industry!]
  industry: Industry
  isDeletedSuccessful: Boolean
}

type Reactions {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  reactionType: String!
}

type Likes {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  postId: String!
  reactionId: String!
  userId: String!
  reactions: Reactions
  user: User
}

type LikesEdge {
  cursor: String!
  node: Likes!
}

type ReactionsPagination {
  edges: [LikesEdge!]
  nodes: [Likes!]
  totalCount: Int!
  hasNextPage: Boolean!
}

type LikesPayload {
  likes: Likes
  isDisliked: Boolean
}

type ReplyToCommentPayload {
  errors: [CustomError!]
  replies: Replies
}

type RepliesToRepliesPayload {
  errors: [CustomError!]
  replies: RepliesToReplies
}

type CommentReactions {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  reactionId: String
  commentId: String
  creatorId: String
  comment: Comment
  reactors: [User!]
}

type CommentReactionsEdge {
  cursor: String!
  node: CommentReactions!
}

type CommentReactionsPagination {
  edges: [CommentReactionsEdge!]
  nodes: [CommentReactions!]
  totalCount: Int!
  hasNextPage: Boolean!
}

type CommentReactionsPayload {
  errors: [CustomError!]
  commentReactions: CommentReactions
  isDisliked: Boolean
}

type CommentReactionPaginationPayload {
  errors: [CustomError!]
  reactions: CommentReactionsPagination
}

type Query {
  listUsers(
    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
    order: OrderListUsers = {direction: desc, orderBy: username}
    filter: FilterListUsers
  ): UserPaginated!
  me: User!
  getUser(userId: String!): User!
  getCompanysFollowedByUser(
    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
    order: OrderFollowedCompanyList
  ): CompanyPaginated
  companiesSuggestions(
    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
    order: OrderListCompanies = {direction: desc, orderBy: name}
    filter: FilterListCompanies
  ): CompanyPaginated!
  companies(
    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
    order: OrderListCompanies = {direction: desc, orderBy: name}
    filter: FilterListCompanies
  ): CompanyPaginated!
  getCompanyById(id: String!): Company!
  getBranchesByCompanyId(id: String!): [Branch!]!
  getTags(paginate: PaginationArgs = {skip: 0, take: 50}, order: OrderTagList = {direction: asc, orderBy: createdAt}, query: TagQuery = {name: ""}): TagPagination!
  postsByCompanyId(
    id: String!

    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
  ): PostPagination!
  companyPostsFollowedByUser(
    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
    order: OrderPosts = {direction: desc, orderBy: createdAt}
  ): PostPagination
  comments(
    postId: String!

    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
    order: OrderCommentsList = {direction: asc, orderBy: createdAt}
  ): CommentPaginationPayload!
  getIndustry: IndustryPayload!
  getReactions: [Reactions!]!
  getLikesByPost(postId: String!, paginate: PaginationArgs = {skip: 0, take: 50}, order: ReactionsOrderList = {direction: desc}): ReactionsPagination!
  getUsersByPostReaction(reactionType: String!, paginate: PaginationArgs = {skip: 0, take: 50}, order: ReactionsOrderList = {direction: desc}): ReactionsPagination!
  commentReactions(commentId: String!, paginate: PaginationArgs = {skip: 0, take: 50}, order: CommentReactionsOrderList = {direction: asc, orderBy: createdAt}): CommentReactionPaginationPayload!
}

input OrderListUsers {
  direction: OrderDirection!
  orderBy: UsersOrderBy!
}

"""Order by: username, createdAt, email"""
enum UsersOrderBy {
  username
  createdAt
  email
}

input FilterListUsers {
  omni: String = null
  isValid: Boolean = null
}

input OrderFollowedCompanyList {
  direction: OrderDirection!
  orderBy: FollowedCompanyOrderBy!
}

"""Order by: createdAt"""
enum FollowedCompanyOrderBy {
  createdAt
}

input OrderListCompanies {
  direction: OrderDirection!
  orderBy: CompaniesOrderBy!
}

"""Order by: name, legalName, createdAt"""
enum CompaniesOrderBy {
  name
  legalName
  createdAt
}

input FilterListCompanies {
  omni: String = null
}

input PaginationArgs {
  skip: Float!
  take: Float!
}

input OrderTagList {
  direction: OrderDirection!
  orderBy: TagOrderBy!
}

"""Order by:createdAt"""
enum TagOrderBy {
  createdAt
}

input TagQuery {
  name: String = null
}

input OrderPosts {
  direction: OrderDirection!
  orderBy: PostsOrderBy!
}

"""Order by: createdAt"""
enum PostsOrderBy {
  createdAt
}

input ReactionsOrderList {
  direction: OrderDirection!
  orderBy: ReactionsOrderBy!
}

"""Order By:createdAt"""
enum ReactionsOrderBy {
  createdAt
}

input CommentReactionsOrderList {
  direction: OrderDirection!
  orderBy: CommentReactionsOrderBy
}

"""Order by:createdAt"""
enum CommentReactionsOrderBy {
  createdAt
}

type Mutation {
  updateStatusUser(data: UpdateStatusUserInput!): User!
  updateUser(data: UpdateUserInput!): User!
  changePassword(data: ChangePasswordInput!): User!
  editUserProfile(userProfile: UserProfileInput!, file: Upload): UserProfilePayload!
  signup(data: SignupInput!): Auth!
  login(data: LoginInput!): Auth!
  loginLinkAccess(data: LoginLinkAccessInput!): Boolean!
  refreshToken(token: String!): Token!
  confirmEmail(token: String!): Token!
  requestConfirmEmail(data: RequestConfirmEmailInput!): Boolean!
  resetPassword(data: ResetPasswordInput!): Token!
  requestResetPassword(data: RequestResetPasswordInput!): Boolean!
  logout: Boolean!
  createCompany(data: CreateCompanyInput!): Company!
  createCompanyGeneralInfo(data: CreateCompanyGeneralInput!): Company!
  editCompany(id: String!, data: CompanyEditInput!, file: Upload): CompanyPayload!
  createCompanyBranch(id: String!, data: CompanyBranchInput!): Branch!
  editCompanyBranch(id: String!, data: CompanyBranchEditInput!): Branch!
  deleteCompanyBranch(id: String!, companyId: String!): Branch!
  post(data: CreatePostInput!, companyId: String!, file: [Upload!]): CreatePostPayload!
  postUpdate(id: String!, imageURL: String, input: UpdatePostInput, file: Upload): UpdatePostPayload!
  postDelete(postId: String!): DeletePostPayload!
  upvotePost(postId: Int!): RatePayload!
  downvotePost(postId: Int!): RatePayload!
  removeRatingFromPost(postId: Int!): RatePayload!
  commentToPost(postId: String!, input: CreateCommentInput!, mention: CreateMentionsInput): NewReplyPayload!
  upvoteComment(commentId: String!): RatePayload!
  downvoteComment(commentId: String!): RatePayload!
  removeRatingFromComment(commentId: String!): RatePayload!
  inviteEmployee(data: InvitedEmployeeInput!): InvitedEmployee!
  createEmployee(data: UserEmployeeInput!): User!
  followCompany(data: FollowCompanyInput!): FollowCompany!
  unfollowCompany(data: UnfollowCompanyInput!): String!
  followUserToUser(data: FollowUserToUserInput!): FollowUserToUser!
  unfollowUser(data: UnfollowUserInput!): String!
  createIndustry(data: IndustryInput!): IndustryPayload!
  updateIndustry(id: String!, data: IndustryInput!): IndustryPayload!
  deleteIndustry(id: String!): IndustryPayload!
  activeOrDeactiveIndustry(id: String!): IndustryPayload!
  createLikes(data: LikesInput!): LikesPayload!
  removeLike(postId: String!): Likes!
  commentReply(commentId: String!, input: CreateCommentInput!, mention: CreateMentionsInput): ReplyToCommentPayload!
  replyToReply(commentId: String!, input: CreateCommentInput!, mention: CreateMentionsInput): RepliesToRepliesPayload!
  commentReaction(input: CommentReactionsInput!): CommentReactionsPayload!
}

input UpdateStatusUserInput {
  userId: String!
  status: Boolean!
}

input UpdateUserInput {
  userId: String
  fullName: String
}

input ChangePasswordInput {
  oldPassword: String!
  newPassword: String!
}

input UserProfileInput {
  address: String!
  phoneNo: String!
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

input SignupInput {
  fullName: String
  email: String!
  password: String!
  isCompanyAccount: Boolean
  legalName: String
}

input LoginInput {
  emailOrUsername: String!
  password: String!
}

input LoginLinkAccessInput {
  email: String!
}

input RequestConfirmEmailInput {
  email: String!
}

input ResetPasswordInput {
  newPassword: String!
  token: String!
}

input RequestResetPasswordInput {
  email: String!
}

input CreateCompanyInput {
  name: String!
  legalName: String!
  registrationNumber: String!
  establishedDate: DateTime!
  businessType: String!
  ownership: String!
  companyStage: String!
  branches: Float!
  numberOfemployees: Float!
  transactions: Float!
}

input CreateCompanyGeneralInput {
  name: String!
  legalName: String!
  registrationNumber: String!
  establishedDate: DateTime!
  businessType: String!
  ownership: String!
  companyStage: String!
}

input CompanyEditInput {
  legalName: String
  name: String
  registrationNumber: String!
  establishedDate: DateTime!
  companyStage: String
  description: String
  mission: String
  vision: String
  ownership: String
  contactEmail: String!
  numberOfemployees: Float
  transactions: Float
  website: String
  contactNumber: String
  slogan: String
}

input CompanyBranchInput {
  type: BranchType!
  name: String
  contactEmail: String!
  contactNumber: String!
  country: String
  city: String
  zipCode: String
  state: String
  street1: String
  street2: String
}

input CompanyBranchEditInput {
  type: BranchType
  name: String
  contactEmail: String
  contactNumber: String
  country: String
  city: String
  zipCode: String
  state: String
  street1: String
  street2: String
}

input CreatePostInput {
  text: String!
  tags: [String!]
  metaTitle: String
  description: String
}

input UpdatePostInput {
  text: String!
  tags: [String!]
  metaTitle: String
  description: String
}

input CreateCommentInput {
  text: String!
}

input CreateMentionsInput {
  mentionIds: [String!]
}

input InvitedEmployeeInput {
  invitedEmail: String!
  role: String!
}

input UserEmployeeInput {
  isInviteAccepted: Boolean!
  firstName: String!
  lastName: String!
  email: String!
  password: String!
  role: String!
}

input FollowCompanyInput {
  followedToId: String!
}

input UnfollowCompanyInput {
  companyId: String!
}

input FollowUserToUserInput {
  followedToID: String!
}

input UnfollowUserInput {
  userId: String!
}

input IndustryInput {
  type: String!
  description: String
}

input LikesInput {
  postId: String!
  reactionType: String!
}

input CommentReactionsInput {
  reactionType: String!
  commentId: String!
}