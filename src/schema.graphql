# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Branch {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
  type: BranchType!
  contactEmail: String!
  contactNumber: String!
  country: String!
  city: String!
  zipCode: String
  state: String
  street: String
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

"""The branch type can be CORPORATE and BRANCH_OFFICE"""
enum BranchType {
  HEADQUARTER
  BRANCH_OFFICE
}

type CompanyDocument {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  companyId: String
  type: String
  document: String
  company: Company
}

type Company {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
  legalName: String
  registrationNumberType: String
  registrationNumber: String
  establishedDate: DateTime
  companyStage: String
  description: String
  ownership: String
  mission: String
  vision: String
  numberOfemployees: Float
  contactEmail: String
  transactions: Float
  isActive: Boolean
  isVerified: Boolean
  ownerId: String
  website: String
  contactNumber: String
  followers: Float
  slogan: String
  branches: [Branch!]
  avatar: String
  accountStatus: String
  reason: String
  companyDocument: [CompanyDocument!]
}

type CompanyPaginated {
  edges: [CompanyEdge!]
  pageInfo: CompanyPageInfo
  totalCount: Float
}

type CompanyEdge {
  cursor: String
  node: Company
}

type CompanyPageInfo {
  startCursor: String
  endCursor: String
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
}

type RepliesToReplies {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  text: String
  creatorId: String
  repliedToCommentId: String
  repliedToReplyId: String
  repliedToParentComment: Comment
  creator: User
}

type RepliesToRepliesPagination {
  edges: [RepliesToRepliesEdge!]
  pageInfo: RepliesToRepliesPageInfo
  totalCount: Float
}

type RepliesToRepliesEdge {
  cursor: String
  node: RepliesToReplies
}

type RepliesToRepliesPageInfo {
  startCursor: String
  endCursor: String
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
}

type Replies {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  text: String
  postId: String
  creatorId: String
  repliedToCommentId: String
  repliedTo: Comment!
  replies(
    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
    order: OrderCommentsList = {direction: asc, orderBy: createdAt}
  ): RepliesToRepliesPagination!
  creator: User!
  mentions: [User!]!
  post: Post
}

input OrderCommentsList {
  direction: OrderDirection!
  orderBy: CommentOrderBy!
}

"""
Likely likely to sort a list of items when presented with an argument `orderBy`.
"""
enum OrderDirection {
  asc
  desc
}

"""Order by:createdAt"""
enum CommentOrderBy {
  createdAt
}

type RepliesPagination {
  edges: [RepliesEdge!]
  pageInfo: RepliesPageInfo
  totalCount: Float
}

type RepliesEdge {
  cursor: String
  node: Replies
}

type RepliesPageInfo {
  startCursor: String
  endCursor: String
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
}

type Comment {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  text: String!
  creatorId: String!
  postId: String
  repliedToCommentId: String
  repliedToReplyId: String
  rating: Int
  replies(
    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
    order: OrderCommentsList = {direction: asc, orderBy: createdAt}
  ): RepliesPagination
  myRatingStatus: RatingStatus!
  creator: User!
  mentions: [User!]!
  post: Post
}

enum RatingStatus {
  NEUTRAL
  UPVOTED
  DOWNVOTED
}

type CommentPagination {
  edges: [CommentEdge!]
  pageInfo: CommentPageInfo
  totalCount: Float
}

type CommentEdge {
  cursor: String
  node: Comment
}

type CommentPageInfo {
  startCursor: String
  endCursor: String
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
}

type PostImage {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  metaTitle: String
  imageURL: String
  description: String
  postId: String
}

type Tag {
  id: ID!
  name: String!
}

type Post {
  id: ID!
  text: String!
  creator: User!
  rating: Int!
  createdAt: DateTime!
  myRatingStatus: RatingStatus!
  creatorId: String!
  comments: [Comment!]!
  isSaleAble: Boolean
  companyId: String
  postImage: [PostImage!]!
  tags: [Tag!]!
  company: Company
}

type PostPagination {
  edges: [PostEdge!]
  pageInfo: PostPageInfo
  totalCount: Float
}

type PostEdge {
  cursor: String
  node: Post
}

type PostPageInfo {
  startCursor: String
  endCursor: String
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
}

type UserProfile {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  address: String
  phoneNo: String
  profileImage: String
  user: User
}

type User {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  fullName: String
  username: String
  email: String!
  isValid: Boolean
  isSuperuser: Boolean
  confirm: Boolean
  emailToken: String
  isEmailVerified: Boolean
  posts: [Post!]
  company: [Company!]
  userProfile: UserProfile
  isAdmin: Boolean!
}

type UserPaginated {
  edges: [UserEdge!]
  pageInfo: UserPageInfo
  totalCount: Float
}

type UserEdge {
  cursor: String
  node: User
}

type UserPageInfo {
  startCursor: String
  endCursor: String
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
}

type CustomError {
  message: String!
  code: String
  statusCode: Float
}

type OTP {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  otp: Float
  expirationDate: DateTime
  userId: String
}

type OTPPayload {
  errors: [CustomError!]
  otp: OTP
  otpCheck: Boolean
}

type Token {
  """JWT access token"""
  accessToken: String

  """JWT refresh token"""
  refreshToken: String
}

type Auth {
  """JWT access token"""
  accessToken: String

  """JWT refresh token"""
  refreshToken: String
  errors: [CustomError!]
  user: User
  role: String
  otp: OTP
  company: [Company!]
}

type UserProfilePayload {
  errors: CustomError
  userProfile: UserProfile
}

type CompanyPayload {
  errors: [CustomError!]
  company: Company
  companyDocument: [CompanyDocument!]
}

type CompanyDocumentEditPayload {
  errors: [CustomError!]
  company: Company
  companyDocument: CompanyDocument
}

type CompanyBranchPayload {
  errors: [CustomError!]
  branch: Branch
}

type GetCompanyBranchPayload {
  errors: [CustomError!]
  branches: [Branch!]
}

type CompanyBranchDeletePayload {
  errors: [CustomError!]
  isDeleted: Boolean
}

type UserError {
  message: String!
  field: String
  code: String
  status: Float
}

type RatePayload implements MutationPayload {
  errors: [UserError!]
  isRateSuccessful: Boolean!
}

interface MutationPayload {
  errors: [UserError!]
}

type NewReplyPayload implements MutationPayload {
  errors: [UserError!]
  comment: Comment
}

type CommentDeletePayload {
  errors: [UserError!]
  isDeleted: Boolean
}

type CommentPaginationPayload {
  errors: [UserError!]
  comments: CommentPagination
}

type CreatePostPayload {
  errors: [CustomError!]
  post: Post
  postImage: [PostImage!]
  tags: [Tag!]
}

type DeletePostPayload {
  errors: [CustomError!]
  isDeleteSuccessful: Boolean
}

type UpdatePostPayload {
  errors: [CustomError!]
  post: Post
  postImage: PostImage
  tags: [Tag!]
}

type TagEdge {
  cursor: String!
  node: Tag!
}

type TagPagination {
  edges: [TagEdge!]
  nodes: [Tag!]
  totalCount: Int!
  hasNextPage: Boolean!
}

type InvitedEmployee {
  id: ID!
  invitedId: String!
  invitedEmail: String!
  invitedRoleId: String!
  isInviteAccepted: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FollowUserToUser {
  id: ID!
  followedToId: String!
  followedById: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FollowCompany {
  id: ID!
  followedById: String!
  followedToId: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Industry {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  type: String!
  description: String
  isActive: Boolean
}

type IndustryPayload {
  error: String
  industries: [Industry!]
  industry: Industry
  isDeletedSuccessful: Boolean
}

type Reactions {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  reactionType: String!
}

type Likes {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  postId: String!
  reactionId: String!
  userId: String!
  reactions: Reactions
  user: User
}

type LikesEdge {
  cursor: String!
  node: Likes!
}

type ReactionsPagination {
  edges: [LikesEdge!]
  nodes: [Likes!]
  totalCount: Int!
  hasNextPage: Boolean!
}

type LikesPayload {
  likes: Likes
  isDisliked: Boolean
}

type ReplyToCommentPayload {
  errors: [CustomError!]
  replies: Replies
}

type RepliesToRepliesPayload {
  errors: [CustomError!]
  replies: RepliesToReplies
}

type CommentReactions {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  reactionId: String
  commentId: String
  creatorId: String
  comment: Comment
  reactors: [User!]
}

type CommentReactionsEdge {
  cursor: String!
  node: CommentReactions!
}

type CommentReactionsPagination {
  edges: [CommentReactionsEdge!]
  nodes: [CommentReactions!]
  totalCount: Int!
  hasNextPage: Boolean!
}

type CommentReactionsPayload {
  errors: [CustomError!]
  commentReactions: CommentReactions
  isDisliked: Boolean
}

type CommentReactionPaginationPayload {
  errors: [CustomError!]
  reactions: CommentReactionsPagination
}

type CreatedBy {
  id: String
  fullName: String
  image: String
}

type DiscussionAnswerReply {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  answer: String
  discussionId: String
  discussion: CompanyDiscussion
  userId: String
  user: User!
  repliedToAnswerId: String
  parentAnswer: DiscussionAnswer
  upVote: Float
  createdBy: CreatedBy
}

type DiscussionAnswerReplyPaginated {
  edges: [DiscussionAnswerReplyEdge!]
  pageInfo: DiscussionAnswerReplyPageInfo
  totalCount: Float
}

type DiscussionAnswerReplyEdge {
  cursor: String
  node: DiscussionAnswerReply
}

type DiscussionAnswerReplyPageInfo {
  startCursor: String
  endCursor: String
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
}

type DiscussionAnswer {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  answer: String
  discussionId: String
  discussion: CompanyDiscussion
  userId: String
  user: User!
  answerReply(
    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
    order: OrderListDiscussionAnswer = {direction: asc, orderBy: createdAt}
  ): DiscussionAnswerReplyPaginated
  mentions: [User!]
  upVote: Float
  createdBy: CreatedBy
}

input OrderListDiscussionAnswer {
  direction: OrderDirection!
  orderBy: DiscussionAnswerOrderBy!
}

"""Order by:createdAt"""
enum DiscussionAnswerOrderBy {
  createdAt
}

type DiscussionAnswerPaginated {
  edges: [DiscussionAnswerEdge!]
  pageInfo: DiscussionAnswerPageInfo
  totalCount: Float
}

type DiscussionAnswerEdge {
  cursor: String
  node: DiscussionAnswer
}

type DiscussionAnswerPageInfo {
  startCursor: String
  endCursor: String
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
}

type DiscussionVote {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  vote: String
  userId: String
  user: [User!]
  discussionId: String
  discussion: CompanyDiscussion
}

type CompanyDiscussion {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String
  description: String
  companyId: String
  company: Company
  userId: String
  user: User!
  discussionAnswer(
    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
    order: OrderListDiscussionAnswer = {direction: asc, orderBy: createdAt}
  ): DiscussionAnswerPaginated
  discussionVote: [DiscussionVote!]
  upVote: Float
  createdBy: CreatedBy
}

type DiscussionPaginated {
  edges: [CompanyDiscussionEdge!]
  pageInfo: CompanyDiscussionPageInfo
  totalCount: Float
}

type CompanyDiscussionEdge {
  cursor: String
  node: CompanyDiscussion
}

type CompanyDiscussionPageInfo {
  startCursor: String
  endCursor: String
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
}

type CompanyDiscussionPayload {
  errors: [CustomError!]
  companyDiscussion: CompanyDiscussion
}

type CompanyDiscussionDeletePayload {
  errors: [CustomError!]
  isDeleted: Boolean
}

type DiscussionVotePayload {
  errors: [CustomError!]
  discussionVote: DiscussionVote
  removeVote: Boolean
}

type DiscussionAnswerVote {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  vote: String
  discussionId: String
  discussion: CompanyDiscussion
  userId: String
  user: User
  discussionAnswer: DiscussionAnswer
}

type DiscussionAnswerVotePayload {
  errors: [CustomError!]
  discussionAnswerVote: DiscussionAnswerVote
  removeVote: Boolean
}

type DiscussionAnswerPayload {
  errors: [CustomError!]
  discussionAnswer: DiscussionAnswer
}

type DiscussionAnswerReplyPayload {
  errors: [CustomError!]
  discussionAnswerReply: DiscussionAnswerReply
}

type DiscussionAnswerDeletePayload {
  errors: [CustomError!]
  isDeleted: Boolean
}

type CommunityRole {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  role: String
  communityId: String
  userId: String
  user: User
  community: Community
  company: Company
}

type Community {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String
  description: String
  type: String
  profile: String
  companyId: String
  creatorId: String
  slug: String
  company: Company
  createdBy: User
  members(
    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
    order: OrderListCommunityMember = {direction: desc, orderBy: createdAt}
  ): CommunityMemberPaginated
  followersCount: Float
  communityRole: [CommunityRole!]
}

input OrderListCommunityMember {
  direction: OrderDirection!
  orderBy: CommunityMemberOrderBy!
}

"""Order by:createdAt"""
enum CommunityMemberOrderBy {
  createdAt
}

type CommunityPaginated {
  edges: [CommunityEdge!]
  pageInfo: CommunityPageInfo
  totalCount: Float
}

type CommunityEdge {
  cursor: String
  node: Community
}

type CommunityPageInfo {
  startCursor: String
  endCursor: String
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
}

type CommunityMember {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  communityId: String
  invitedById: String
  memberId: String
  community: Community
}

type CommunityMemberPaginated {
  edges: [CommunityMemberEdge!]
  pageInfo: CommunityMemberPageInfo
  totalCount: Float
}

type CommunityMemberEdge {
  cursor: String
  node: CommunityMember
}

type CommunityMemberPageInfo {
  startCursor: String
  endCursor: String
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
}

type CommunityMemberPayload {
  errors: [CustomError!]
  communityMember: [CommunityMember!]
}

type GetCommunityMemberPayload {
  errors: [CustomError!]
  communityMember: CommunityMemberPaginated
}

type JoinCommunityPayload {
  errors: [CustomError!]
  joinCommunity: CommunityMember
}

type AcceptInvitePayload {
  errors: [CustomError!]
  isAccepted: Boolean
}

type CommunityPayload {
  errors: [CustomError!]
  community: Community
}

type GetCommunityPayload {
  errors: [CustomError!]
  community: CommunityPaginated
}

type CommunityDeletePayload {
  errors: [CustomError!]
  isDeleted: Boolean
}

type Query {
  listUsers(
    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
    order: OrderListUsers = {direction: desc, orderBy: username}
    filter: FilterListUsers
  ): UserPaginated!
  me: User!
  getUser(userId: String!): User!
  getCompanysFollowedByUser(
    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
    order: OrderFollowedCompanyList
  ): CompanyPaginated
  companiesSuggestions(
    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
    order: OrderListCompanies = {direction: desc, orderBy: name}
    filter: FilterListCompanies
  ): CompanyPaginated!
  companies(
    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
    order: OrderListCompanies = {direction: desc, orderBy: name}
    filter: FilterListCompanies
  ): CompanyPaginated!
  getCompanyById(id: String!): Company!
  getBranchesByCompanyId(id: String!): GetCompanyBranchPayload!
  getTags(paginate: PaginationArgs = {skip: 0, take: 50}, order: OrderTagList = {direction: asc, orderBy: createdAt}, query: TagQuery = {name: ""}): TagPagination!
  postsByCompanyId(
    id: String!

    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
  ): PostPagination!
  companyPostsFollowedByUser(
    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
    order: OrderPosts = {direction: desc, orderBy: createdAt}
  ): PostPagination
  comments(
    postId: String!

    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
    order: OrderCommentsList = {direction: asc, orderBy: createdAt}
  ): CommentPaginationPayload!
  getIndustry: IndustryPayload!
  getReactions: [Reactions!]!
  getLikesByPost(postId: String!, paginate: PaginationArgs = {skip: 0, take: 50}, order: ReactionsOrderList = {direction: desc}): ReactionsPagination!
  getUsersByPostReaction(reactionType: String!, paginate: PaginationArgs = {skip: 0, take: 50}, order: ReactionsOrderList = {direction: desc}): ReactionsPagination!
  commentReactions(commentId: String!, paginate: PaginationArgs = {skip: 0, take: 50}, order: CommentReactionsOrderList = {direction: asc, orderBy: createdAt}): CommentReactionPaginationPayload!
  getCompanyDiscussion(
    companyId: String!

    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
    order: OrderListDiscussion = {direction: desc, orderBy: createdAt}
  ): DiscussionPaginated!
  getCompanyDiscussionById(discussionId: String!): CompanyDiscussion!
  getCompanyDiscussionByUser: [CompanyDiscussion!]!
  discussionVoteCount(discussionId: String!): Float!
  getDiscussionAnswerByDiscussionId(
    discussionId: String!

    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
    order: OrderListDiscussionAnswer = {direction: asc, orderBy: createdAt}
  ): DiscussionAnswerPaginated!
  getCommunity(
    companyId: String!

    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
    order: OrderListCommunity = {direction: desc, orderBy: name}
  ): GetCommunityPayload!
  getCommunityById(communityId: String!): CommunityPayload!
  getCommunityMember(
    communityId: String!

    """Paginate before opaque cursor"""
    before: String

    """Paginate after opaque cursor"""
    after: String

    """Paginate first"""
    first: Float

    """Paginate last"""
    last: Float
    order: OrderListCommunityMember = {direction: desc, orderBy: createdAt}
  ): GetCommunityMemberPayload!
}

input OrderListUsers {
  direction: OrderDirection!
  orderBy: UsersOrderBy!
}

"""Order by: username, createdAt, email"""
enum UsersOrderBy {
  username
  createdAt
  email
}

input FilterListUsers {
  omni: String = null
  isValid: Boolean = null
}

input OrderFollowedCompanyList {
  direction: OrderDirection!
  orderBy: FollowedCompanyOrderBy!
}

"""Order by: createdAt"""
enum FollowedCompanyOrderBy {
  createdAt
}

input OrderListCompanies {
  direction: OrderDirection!
  orderBy: CompaniesOrderBy!
}

"""Order by: name, legalName, createdAt"""
enum CompaniesOrderBy {
  name
  legalName
  createdAt
}

input FilterListCompanies {
  omni: String = null
}

input PaginationArgs {
  skip: Float!
  take: Float!
}

input OrderTagList {
  direction: OrderDirection!
  orderBy: TagOrderBy!
}

"""Order by:createdAt"""
enum TagOrderBy {
  createdAt
}

input TagQuery {
  name: String = null
}

input OrderPosts {
  direction: OrderDirection!
  orderBy: PostsOrderBy!
}

"""Order by: createdAt"""
enum PostsOrderBy {
  createdAt
}

input ReactionsOrderList {
  direction: OrderDirection!
  orderBy: ReactionsOrderBy!
}

"""Order By:createdAt"""
enum ReactionsOrderBy {
  createdAt
}

input CommentReactionsOrderList {
  direction: OrderDirection!
  orderBy: CommentReactionsOrderBy
}

"""Order by:createdAt"""
enum CommentReactionsOrderBy {
  createdAt
}

input OrderListDiscussion {
  direction: OrderDirection!
  orderBy: DiscussionOrderBy!
}

"""Order by:createdAt"""
enum DiscussionOrderBy {
  createdAt
}

input OrderListCommunity {
  direction: OrderDirection!
  orderBy: CommunityOrderBy!
}

"""Order by:createdAt, name"""
enum CommunityOrderBy {
  createdAt
  name
}

type Mutation {
  updateStatusUser(data: UpdateStatusUserInput!): User!
  updateUser(data: UpdateUserInput!): User!
  changePassword(data: ChangePasswordInput!): User!
  editUserProfile(userProfile: UserProfileInput!, file: Upload): UserProfilePayload!
  signup(data: SignupInput!): Auth!
  login(data: LoginInput!): Auth!
  loginLinkAccess(data: LoginLinkAccessInput!): Boolean!
  refreshToken(token: String!): Token!
  confirmEmail(token: String!): Token!
  requestConfirmEmail(data: RequestConfirmEmailInput!): Boolean!
  resetPassword(data: ResetPasswordInput!): Token!
  requestResetPassword(data: RequestResetPasswordInput!): Boolean!
  logout: Boolean!
  otpVerification(otp: Float!): OTPPayload!
  resendOtp: OTPPayload!
  createCompany(data: CreateCompanyInput!): Company!
  createCompanyGeneralInfo(data: CreateCompanyGeneralInput!): Company!
  companyGeneralInfoEdit(companyId: String!, data: CompanyEditInput!): CompanyPayload!
  companyAvatar(companyId: String!, avatar: Upload!): CompanyPayload!
  createCompanyBranch(id: String!, data: CompanyBranchInput!): CompanyBranchPayload!
  editCompanyBranch(id: String!, data: CompanyBranchEditInput!): CompanyBranchPayload!
  deleteCompanyBranch(id: String!, companyId: String!): CompanyBranchDeletePayload!
  companyAccountStatus(data: CompanyAccountStatus!, companyId: String!): CompanyPayload!
  companyDocumentCreate(input: CompanyDocumentInput!, document: [Upload!]!): CompanyPayload!
  companyDocumentEdit(companyId: String!, documentId: String!, editDocument: CompanyDocumentEditInput!, document: Upload!): CompanyDocumentEditPayload!
  post(data: CreatePostInput!, companyId: String!, file: [Upload!]): CreatePostPayload!
  postUpdate(id: String!, imageURL: String, input: UpdatePostInput, file: Upload): UpdatePostPayload!
  postDelete(postId: String!): DeletePostPayload!
  upvotePost(postId: Int!): RatePayload!
  downvotePost(postId: Int!): RatePayload!
  removeRatingFromPost(postId: Int!): RatePayload!
  commentToPost(postId: String!, input: CreateCommentInput!, mention: CreateMentionsInput): NewReplyPayload!
  commentUpdate(commentId: String!, input: CreateCommentInput!, mention: CreateMentionsInput): NewReplyPayload!
  commentDelete(commentId: String!): CommentDeletePayload!
  upvoteComment(commentId: String!): RatePayload!
  downvoteComment(commentId: String!): RatePayload!
  removeRatingFromComment(commentId: String!): RatePayload!
  inviteEmployee(data: InvitedEmployeeInput!): InvitedEmployee!
  createEmployee(data: UserEmployeeInput!): User!
  followCompany(data: FollowCompanyInput!): FollowCompany!
  unfollowCompany(data: UnfollowCompanyInput!): String!
  followUserToUser(data: FollowUserToUserInput!): FollowUserToUser!
  unfollowUser(data: UnfollowUserInput!): String!
  createIndustry(data: IndustryInput!): IndustryPayload!
  updateIndustry(id: String!, data: IndustryInput!): IndustryPayload!
  deleteIndustry(id: String!): IndustryPayload!
  activeOrDeactiveIndustry(id: String!): IndustryPayload!
  createLikes(data: LikesInput!): LikesPayload!
  removeLike(postId: String!): Likes!
  commentReply(commentId: String!, input: CreateCommentInput!, mention: CreateMentionsInput): ReplyToCommentPayload!
  replyToReply(commentId: String!, input: CreateCommentInput!, mention: CreateMentionsInput): RepliesToRepliesPayload!
  commentReaction(input: CommentReactionsInput!): CommentReactionsPayload!
  companyDiscussion(input: CompanyDiscussionInput!): CompanyDiscussionPayload!
  companyDiscussionUpdate(input: CompanyDiscussionUpdateInput!, discussionId: String!): CompanyDiscussionPayload!
  companyDiscussionDelete(id: String!): CompanyDiscussionDeletePayload!
  discussionVote(input: DiscussionVoteInput!): DiscussionVotePayload!
  discussionDownvote(input: DiscussionVoteInput!): DiscussionVotePayload!
  createDiscussionAnswer(answer: DiscussionAnswerInput!): DiscussionAnswerPayload!
  discussionAnswerUpdate(updateAnswer: DiscussionAnswerUpdateInput!, answerId: String!): DiscussionAnswerPayload!
  discussionAnswerDelete(id: String!): DiscussionAnswerDeletePayload!
  discussionAnswerVote(input: DiscussionAnswerVoteInput!): DiscussionAnswerVotePayload!
  discussionAnswerDownvote(input: DiscussionAnswerVoteInput!): DiscussionAnswerVotePayload!
  discussionAnswerReply(input: ReplyToAnswerInput!): DiscussionAnswerReplyPayload!
  companyCommunity(input: CommunityInput!, profile: Upload!): CommunityPayload!
  companyCommunityEdit(communityId: String!, input: CommunityEditInput!, profile: Upload!): CommunityPayload!
  companyCommunityDelete(communityId: String!): CommunityDeletePayload!
  inviteUserByCommunityAdmin(input: CommunityMemberInviteInput!): CommunityMemberPayload!
  acceptCommunityInvite(companyId: String!, communityMemberId: String!): AcceptInvitePayload!
  inviteUserByCommunityUser(input: CommunityMemberInviteInput!): CommunityMemberPayload!
  joinPublicCommunity(input: CommunityMemberInput!): JoinCommunityPayload!
}

input UpdateStatusUserInput {
  userId: String!
  status: Boolean!
}

input UpdateUserInput {
  userId: String
  fullName: String
}

input ChangePasswordInput {
  oldPassword: String!
  newPassword: String!
}

input UserProfileInput {
  address: String!
  phoneNo: String!
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

input SignupInput {
  fullName: String
  email: String!
  password: String!
  isCompanyAccount: Boolean
  legalName: String
}

input LoginInput {
  emailOrUsername: String!
  password: String!
}

input LoginLinkAccessInput {
  email: String!
}

input RequestConfirmEmailInput {
  email: String!
}

input ResetPasswordInput {
  newPassword: String!
  token: String!
}

input RequestResetPasswordInput {
  email: String!
}

input CreateCompanyInput {
  name: String!
  legalName: String!
  registrationNumber: String!
  establishedDate: DateTime!
  businessType: String!
  ownership: String!
  companyStage: String!
  branches: Float!
  numberOfemployees: Float!
  transactions: Float!
}

input CreateCompanyGeneralInput {
  name: String!
  legalName: String!
  registrationNumber: String!
  establishedDate: DateTime!
  businessType: String!
  ownership: String!
  companyStage: String!
}

input CompanyEditInput {
  name: String
  legalName: String
  description: String
  registrationNumberType: String
  registrationNumber: String!
  establishedDate: DateTime!
  slogan: String
  companyStage: String
}

input CompanyBranchInput {
  type: BranchType!
  contactEmail: String!
  contactNumber: String!
  country: String
  city: String
  zipCode: String
  state: String
  street: String
}

input CompanyBranchEditInput {
  type: BranchType
  contactEmail: String
  contactNumber: String
  country: String
  city: String
  zipCode: String
  state: String
  street: String
}

input CompanyAccountStatus {
  accountStatus: String!
  reason: String
}

input CompanyDocumentInput {
  companyId: String!
  type: String!
}

input CompanyDocumentEditInput {
  type: String!
}

input CreatePostInput {
  text: String!
  tags: [String!]
  metaTitle: String
  description: String
}

input UpdatePostInput {
  text: String!
  tags: [String!]
  metaTitle: String
  description: String
}

input CreateCommentInput {
  text: String!
}

input CreateMentionsInput {
  mentionIds: [String!]
}

input InvitedEmployeeInput {
  invitedEmail: String!
  role: String!
}

input UserEmployeeInput {
  isInviteAccepted: Boolean!
  firstName: String!
  lastName: String!
  email: String!
  password: String!
  role: String!
}

input FollowCompanyInput {
  followedToId: String!
}

input UnfollowCompanyInput {
  companyId: String!
}

input FollowUserToUserInput {
  followedToID: String!
}

input UnfollowUserInput {
  userId: String!
}

input IndustryInput {
  type: String!
  description: String
}

input LikesInput {
  postId: String!
  reactionType: String!
}

input CommentReactionsInput {
  reactionType: String!
  commentId: String!
}

input CompanyDiscussionInput {
  title: String!
  description: String!
  companyId: String!
}

input CompanyDiscussionUpdateInput {
  title: String!
  description: String!
}

input DiscussionVoteInput {
  discussionId: String!
  vote: String!
}

input DiscussionAnswerInput {
  answer: String!
  discussionId: String!
  mentionIds: [String!]
}

input DiscussionAnswerUpdateInput {
  answer: String!
  mentionIds: [String!]
}

input DiscussionAnswerVoteInput {
  discussionId: String!
  discussionAnswerId: String!
  vote: String!
}

input ReplyToAnswerInput {
  repliedToAnswerId: String!
  answer: String!
  discussionId: String!
}

input CommunityInput {
  name: String!
  description: String!
  type: String!
  companyId: String!
}

input CommunityEditInput {
  name: String!
  description: String!
  type: String!
}

input CommunityMemberInviteInput {
  communityId: String!
  companyId: String!
  memberId: [String!]
}

input CommunityMemberInput {
  communityId: String!
  companyId: String!
}