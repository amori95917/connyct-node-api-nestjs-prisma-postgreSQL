# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type User {
  id: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  firstName: String!
  lastName: String!
  email: String!
  isValid: Boolean!
  isSuperuser: Boolean
  confirm: Boolean!
  isAdmin: Boolean!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type UserEdge {
  cursor: String!
  node: User!
}

type UserPaginated {
  edges: [UserEdge!]
  nodes: [User!]
  totalCount: Int!
  hasNextPage: Boolean!
}

type Token {
  """JWT access token"""
  accessToken: String!

  """JWT refresh token"""
  refreshToken: String!
}

type Auth {
  """JWT access token"""
  accessToken: String!

  """JWT refresh token"""
  refreshToken: String!
  user: User!
}

type Company {
  id: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  legalName: String!
  registrationNumber: String!
  establishedDate: DateTime!
  businessType: String!
  ownership: String!
  companyStage: String!
  country: String!
  city: String!
  state: String!
  zipCode: String!
  address1: String!
  address2: String!
}

type CompanyEdge {
  cursor: String!
  node: Company!
}

type CompanyPaginated {
  edges: [CompanyEdge!]
  nodes: [Company!]
  totalCount: Int!
  hasNextPage: Boolean!
}

type Query {
  listUsers(paginate: PaginationArgs = {skip: 0, take: 50}, order: OrderListUsers = {direction: desc, orderBy: username}, filter: FilterListUsers): UserPaginated!
  me: User!
  getUser(userId: String!): User!
  companies(paginate: PaginationArgs = {skip: 0, take: 50}, order: OrderListCompanies = {direction: desc, orderBy: name}, filter: FilterListCompanies): CompanyPaginated!
}

input PaginationArgs {
  skip: Float!
  take: Float!
}

input OrderListUsers {
  direction: OrderDirection!
  orderBy: UsersOrderBy!
}

"""
Likely likely to sort a list of items when presented with an argument `orderBy`.
"""
enum OrderDirection {
  asc
  desc
}

"""Order by: username, createdAt, email"""
enum UsersOrderBy {
  username
  createdAt
  email
}

input FilterListUsers {
  omni: String = null
  isValid: Boolean = null
}

input OrderListCompanies {
  direction: OrderDirection!
  orderBy: CompaniesOrderBy!
}

"""Order by: name, legalName, createdAt"""
enum CompaniesOrderBy {
  name
  legalName
  createdAt
}

input FilterListCompanies {
  omni: String = null
}

type Mutation {
  updateStatusUser(data: UpdateStatusUserInput!): User!
  updateUser(data: UpdateUserInput!): User!
  changePassword(data: ChangePasswordInput!): User!
  signup(data: SignupInput!): Auth!
  login(data: LoginInput!): Auth!
  loginLinkAccess(data: LoginLinkAccessInput!): Boolean!
  refreshToken(token: String!): Token!
  confirmEmail(token: String!): Token!
  requestConfirmEmail(data: RequestConfirmEmailInput!): Boolean!
  resetPassword(data: ResetPasswordInput!): Token!
  requestResetPassword(data: RequestResetPasswordInput!): Boolean!
}

input UpdateStatusUserInput {
  userId: String!
  status: Boolean!
}

input UpdateUserInput {
  userId: String
  firstName: String
  lastName: String
}

input ChangePasswordInput {
  oldPassword: String!
  newPassword: String!
}

input SignupInput {
  firstName: String!
  lastName: String!
  email: String!
  username: String!
  password: String!
  isCompanyAccount: Boolean!
}

input LoginInput {
  email: String!
  password: String!
}

input LoginLinkAccessInput {
  email: String!
}

input RequestConfirmEmailInput {
  email: String!
}

input ResetPasswordInput {
  newPassword: String!
  token: String!
}

input RequestResetPasswordInput {
  email: String!
}